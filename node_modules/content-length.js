
var fs = require('fs')


function contentLength (req, options, done) {
  if (options.headers.get('transfer-encoding') === 'chunked' ||
      options.headers.get('content-length') !== undefined) {
    return done()
  }

  if (options.body && !req._src) {
    done(contentLengthSync(options.body))
  }
  else if (!options.multipart && req._src) {
    contentLengthAsync(req._src, done)
  }
  else if (options.multipart) {
    contentLengthMultipart(req._src, done)
  }
}

function contentLengthSync (body) {
  var length = 0
  if (typeof body === 'string') {
    length = Buffer.byteLength(body)
  }
  else if (Array.isArray(body)) {
    length = body.reduce(function (a, b) {return a + b.length}, 0)
  }
  else if (Buffer.isBuffer(body)) {
    length = body.length
  }

  return length
}

function contentLengthAsync (body, done) {
  // file stream
  if (body.hasOwnProperty('fd')) {
    fs.stat(body.path, function (err, stats) {
      if (err) return done(0)
      done(stats.size)
    })
  }
  // http response
  else if (body.hasOwnProperty('httpVersion')) {
    done(parseInt(body.headers['content-length']))
  }
  // request stream
  else if (body.hasOwnProperty('httpModule')) {
    body.on('response', function (res) {
      body.pause()
      done(parseInt(res.headers['content-length']))
    })
    body.resume()
  }
  else {
    done(0)
  }
}

function contentLengthMultipart (body, done) {
  var length = 0
  body._items.forEach(function (item) {
    length += contentLengthSync(item)
  })
  if (!body._streams.length) return done(length)

  // should be parallel
  ;(function loop (index) {
    if (index === body._streams.length) {
      return done(length)
    }
    var stream = body._streams[index]
    contentLengthAsync(stream, function (len) {
      length += len
      loop(++index)
    })
  }(0))
}

module.exports = contentLength
