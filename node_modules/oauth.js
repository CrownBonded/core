'use strict'

var url = require('url')
  , crypto = require('crypto')
var qs = require('qs')
  , uuid = require('node-uuid')
  , _oauth = require('oauth-sign')


function oauth (req, options) {
  var form
    , query
    , contentType = options.headers.get('content-type') || ''
    , formContentType = 'application/x-www-form-urlencoded'
    , transport = options.oauth.transport_method || 'header'

  if (contentType.slice(0, formContentType.length) === formContentType) {
    contentType = formContentType
    form = options.body
  }
  // should store somewhere the parse URL
  var uri = options.uri || {}
  if (uri.query) {
    query = uri.query
  }
  if (transport === 'body' &&
    (options.method !== 'POST' || contentType !== formContentType)) {
    // self.request.emit('error',
    //   new Error('oauth: transport_method of body requires POST ' +
    //   'and content-type ' + formContentType))
  }

  if (!form && typeof options.oauth.body_hash === 'boolean') {
    options.oauth.body_hash =
      buildBodyHash(options.oauth, options.body.toString())
  }

  var oa = buildParams(options.oauth, uri, options.method, query, form)

  if (transport === 'header') {
    options.headers.set('authorization', 'OAuth ' + concatParams(oa, ',', '"'))
  }
  else if (transport === 'query') {
    var href = options.uri.href += (query ? '&' : '?') + concatParams(oa, '&')

    // options.uri = url.parse(href)
    // self.request.path = self.request.uri.path
  }
  else if (transport === 'body') {
    options.body = (form ? form + '&' : '') + concatParams(oa, '&')
  }
}

function buildParams (oauth, uri, method, query, form) {
  var oa = {}
  for (var key in oauth) {
    var param = (!/^oauth_/.test(key)) ? ('oauth_' + key) : key
    oa[param] = oauth[key]
  }
  if (!oa.oauth_version) {
    oa.oauth_version = '1.0'
  }
  if (!oa.oauth_timestamp) {
    oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString()
  }
  if (!oa.oauth_nonce) {
    oa.oauth_nonce = uuid().replace(/-/g, '')
  }
  if (!oa.oauth_signature_method) {
    oa.oauth_signature_method = 'HMAC-SHA1'
  }

  var consumer_secret_or_private_key =
    oa.oauth_consumer_secret || oa.oauth_private_key
  delete oa.oauth_consumer_secret
  delete oa.oauth_private_key

  var token_secret = oa.oauth_token_secret
  delete oa.oauth_token_secret

  var realm = oa.oauth_realm
  delete oa.oauth_realm
  delete oa.oauth_transport_method

  var baseurl = uri.protocol + '//' + uri.host + uri.pathname
  var params = qs.parse([].concat(query, form, qs.stringify(oa)).join('&'))

  oa.oauth_signature = _oauth.sign(
    oa.oauth_signature_method,
    method,
    baseurl,
    params,
    consumer_secret_or_private_key,
    token_secret)

  if (realm) {
    oa.realm = realm
  }

  return oa
}

function buildBodyHash (oauth, body) {
  if (['HMAC-SHA1', 'RSA-SHA1']
    .indexOf(oauth.signature_method || 'HMAC-SHA1') < 0) {
    // this.request.emit('error',
    //   new Error('oauth: ' + oauth.signature_method +
    //   ' signature_method not supported with body_hash signing.'))
  }

  var shasum = crypto.createHash('sha1')
  shasum.update(body || '')
  var sha1 = shasum.digest('hex')

  return new Buffer(sha1).toString('base64')
}

function concatParams (oa, sep, wrap) {
  wrap = wrap || ''

  var params = Object.keys(oa).filter(function (i) {
    return i !== 'realm' && i !== 'oauth_signature'
  }).sort()

  if (oa.realm) {
    params.splice(0, 0, 'realm')
  }
  params.push('oauth_signature')

  return params.map(function (i) {
    return i + '=' + wrap + _oauth.rfc3986(oa[i]) + wrap
  }).join(sep)
}

module.exports = oauth
