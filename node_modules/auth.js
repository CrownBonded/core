'use strict'

var crypto = require('crypto')
  , uuid = require('node-uuid')


function auth (req, options, res) {
  var auth = options.auth || {}
    , header

  // request
  if (!res) {
    if (auth.user) {
      header = basic(auth)
    }
    else if (auth.bearer) {
      header = bearer(auth)
    }
    else if (options.hawk) {
      header = hawk(options)
    }
    else if (options.httpSignature) {
      header = httpSignature(options)
    }
    else if (options.aws) {
      header = aws(options)
    }
  }
  // response
  else {
    if (auth.sendImmediately) return

    var authHeader = res.headers.get('www-authenticate')
      , authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()

    auth.sendImmediately = true

    if (authVerb === 'basic') {
      header = basic(auth)
    }
    else if (authVerb === 'bearer') {
      header = bearer(auth)
    }
    else if (authVerb === 'digest') {
      header = digest(auth.user, auth.pass, options.method, options.path, authHeader)
    }
  }

  if (header) {
    options.headers.set('authorization', header)
  }
}

function basic (auth) {
  if (auth.sendImmediately || auth.sendImmediately === undefined) {
    auth.sendImmediately = true
    var header = 'Basic ' + toBase64(auth.user + ':' + (auth.pass || ''))
    return header
  }
}

function bearer (auth) {
  if (auth.sendImmediately || auth.sendImmediately === undefined) {
    auth.sendImmediately = true
    var header = 'Bearer ' + (auth.bearer || '')
    return header
  }
}

function digest (user, pass, method, path, authHeader) {
  // TODO: More complete implementation of RFC 2617.
  //   - check challenge.algorithm
  //   - support algorithm="MD5-sess"
  //   - handle challenge.domain
  //   - support qop="auth-int" only
  //   - handle Authentication-Info (not necessarily?)
  //   - check challenge.stale (not necessarily?)
  //   - increase nc (not necessarily?)
  // For reference:
  // http://tools.ietf.org/html/rfc2617#section-3
  // https://github.com/bagder/curl/blob/master/lib/http_digest.c

  var challenge = {}
  var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi
  for (;;) {
    var match = re.exec(authHeader)
    if (!match) {
      break
    }
    challenge[match[1]] = match[2] || match[3]
  }

  var ha1 = md5(user + ':' + challenge.realm + ':' + pass)
  var ha2 = md5(method + ':' + path)
  var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth'
  var nc = qop && '00000001'
  var cnonce = qop && uuid().replace(/-/g, '')
  var digestResponse = qop
    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)
  var authValues = {
    username: user,
    realm: challenge.realm,
    nonce: challenge.nonce,
    uri: path,
    qop: qop,
    response: digestResponse,
    nc: nc,
    cnonce: cnonce,
    algorithm: challenge.algorithm,
    opaque: challenge.opaque
  }

  authHeader = []
  for (var k in authValues) {
    if (authValues[k]) {
      if (k === 'qop' || k === 'nc' || k === 'algorithm') {
        authHeader.push(k + '=' + authValues[k])
      } else {
        authHeader.push(k + '="' + authValues[k] + '"')
      }
    }
  }
  var header = 'Digest ' + authHeader.join(', ')
  return header
}

function toBase64 (str) {
  return (new Buffer(str || '', 'utf8')).toString('base64')
}

function md5 (str) {
  return crypto.createHash('md5').update(str).digest('hex')
}

//

function hawk (options) {
  var hawk = require('hawk')

  var header = hawk.client.header(
    options.uri, options.method, options.hawk).field

  return header
}

function httpSignature (options) {
  var httpSignature = require('http-signature')

  httpSignature.signRequest({
    getHeader: function (header) {
      return options.headers.get(header)
    },
    setHeader: function (header, value) {
      options.headers.set(header, value)
    },
    method: options.method,
    path: options.path
  },
  options.httpSignature)
}

function aws (options, now) {
  var aws = require('aws-sign2')

  var date = new Date()
  options.headers.set('date', date.toUTCString())

  var auth = {
    key: options.aws.key,
    secret: options.aws.secret,
    verb: options.method.toUpperCase(),
    date: date,
    contentType: options.headers.get('content-type') || '',
    md5: options.headers.get('content-md5') || '',
    amazonHeaders: aws.canonicalizeHeaders(options.headers.toObject())
  }
  var path = options.uri.path
  if (options.aws.bucket && path) {
    auth.resource = '/' + options.aws.bucket + path
  }
  else if (options.aws.bucket && !path) {
    auth.resource = '/' + options.aws.bucket
  }
  else if (!options.aws.bucket && path) {
    auth.resource = path
  }
  else if (!options.aws.bucket && !path) {
    auth.resource = '/'
  }
  auth.resource = aws.canonicalizeResource(auth.resource)

  var header = aws.authorization(auth)
  return header
}

module.exports = auth
