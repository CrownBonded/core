'use strict'

var crypto = require('crypto')
  , uuid = require('node-uuid')


function auth (req, options, res) {
  var auth = options.auth
    , header

  // request
  if (!res) {
    if (auth.user) {
      header = basic(auth)
    }
    else if (auth.bearer) {
      header = bearer(auth)
    }
  }
  // response
  else {
    if (auth.sendImmediately) return

    var authHeader = res.headers.get('www-authenticate')
      , authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()

    auth.sendImmediately = true

    if (authVerb === 'basic') {
      header = basic(auth)
    }
    else if (authVerb === 'bearer') {
      header = bearer(auth)
    }
    else if (authVerb === 'digest') {
      header = digest(auth.user, auth.pass, options.method, options.path, authHeader)
    }
  }

  if (header) {
    options.headers.set('authorization', header)
  }
}

function basic (auth) {
  if (auth.sendImmediately || auth.sendImmediately === undefined) {
    auth.sendImmediately = true
    var header = 'Basic ' + toBase64(auth.user + ':' + (auth.pass || ''))
    return header
  }
}

function bearer (auth) {
  if (auth.sendImmediately || auth.sendImmediately === undefined) {
    auth.sendImmediately = true
    var header = 'Bearer ' + (auth.bearer || '')
    return header
  }
}

function digest (user, pass, method, path, authHeader) {
  // TODO: More complete implementation of RFC 2617.
  //   - check challenge.algorithm
  //   - support algorithm="MD5-sess"
  //   - handle challenge.domain
  //   - support qop="auth-int" only
  //   - handle Authentication-Info (not necessarily?)
  //   - check challenge.stale (not necessarily?)
  //   - increase nc (not necessarily?)
  // For reference:
  // http://tools.ietf.org/html/rfc2617#section-3
  // https://github.com/bagder/curl/blob/master/lib/http_digest.c

  var challenge = {}
  var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi
  for (;;) {
    var match = re.exec(authHeader)
    if (!match) {
      break
    }
    challenge[match[1]] = match[2] || match[3]
  }

  var ha1 = md5(user + ':' + challenge.realm + ':' + pass)
  var ha2 = md5(method + ':' + path)
  var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth'
  var nc = qop && '00000001'
  var cnonce = qop && uuid().replace(/-/g, '')
  var digestResponse = qop
    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)
  var authValues = {
    username: user,
    realm: challenge.realm,
    nonce: challenge.nonce,
    uri: path,
    qop: qop,
    response: digestResponse,
    nc: nc,
    cnonce: cnonce,
    algorithm: challenge.algorithm,
    opaque: challenge.opaque
  }

  authHeader = []
  for (var k in authValues) {
    if (authValues[k]) {
      if (k === 'qop' || k === 'nc' || k === 'algorithm') {
        authHeader.push(k + '=' + authValues[k])
      } else {
        authHeader.push(k + '="' + authValues[k] + '"')
      }
    }
  }
  var header = 'Digest ' + authHeader.join(', ')
  return header
}

function toBase64 (str) {
  return (new Buffer(str || '', 'utf8')).toString('base64')
}

function md5 (str) {
  return crypto.createHash('md5').update(str).digest('hex')
}

module.exports = auth
